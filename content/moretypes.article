Більше типів: структури, вирізки та словники.
Навчіться описувати типи на основі існуючих: це заняття охоплює структури, масиви, вирізки та словники.

Автори Go
http://golang.org

* Вказівники

В Go є вказівники.
Вказівник містить адресу пам’яті для змінної.

Тип `*T` — вказівник на значення з типом `T`. Його нульовим значенням є `nil`.

	var p *int

Оператор `&` генерує вказівник на свій операнд.

	i := 42
	p = &i

Оператор `*` визначає залежне значення за вказівником.

	fmt.Println(*p) // прочитати i через вказівник p
	*p = 21         // задати i через вказівник p

Це відомо як «розіменування» чи «присвоювання».

На відміну від C, в Go немає адресної арифметики.

.play moretypes/pointers.go

* Структури

`struct` — це колекція полів.

(А оголошення `type` робить те, що ви могли б очікувати.)

.play moretypes/structs.go

* Поля структури

До полів структури звертаються через крапку.

.play moretypes/struct-fields.go

* Вказівники на структури

До полів структури можна звертатися через вказівник на структуру.

Непряма адресація через вказівник є прозорою.

.play moretypes/struct-pointers.go

* Літерали структур

Літерал структури визначає новостворену структуру через перелік значень її полів.

Ви можете перелічити тільки окремий набір полів за допомогою синтаксису `Name:` (порядок іменованих полів неважливий).

Спеціальний префікс `&` повертає вказівник на значення структури.

.play moretypes/struct-literals.go

* Масиви

Тип `[n]T` — масив з `n` значень типу `T`.

Вираз

	var a [10]int

оголошує змінну `a` масивом з десяти цілих.

Розмір масиву є частиною його типу, тож масиви не можуть змінювати розмір.
Це видається обмеженням, але не хвилюйтесь;
Go забезпечує зручний спосіб роботи з масивами.

.play moretypes/array.go

* Вирізки

Вирізка вказує на масив значень, але також включає довжину.

`[]T` — це вирізка з елементами типу `T`.

.play moretypes/slices.go

* Вирізки вирізок

Вирізки можуть бути пере-різані, що створює нове значення вирізки, яке вказує на той самий масив.

Вираз

	s[lo:hi]

визначає вирізку елементів з `lo` до `hi-1`, включно. Отже

	s[lo:lo]

порожня, а

	s[lo:lo+1]

містить один елемент.

.play moretypes/slicing-slices.go

* Створення вирізок

Вирізки створюються функцією `make`. Вона працює через створення обнуленного масиву та повертає вирізку, що посилається на цей масив:

	a := make([]int, 5)  // len(a)=5

Щоб задати ємність, передайте третій параметер для `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go

* Nil вирізки

Нульове значення вирізки — це `nil`.

Nil вирізка має довжину та ємність рівні 0.

.play moretypes/nil-slices.go

* Додавання елементів до вирізки

Поширеним є додавання до вирізки нових елементів, тож Go забезпечує вбудовану
функцію `append`. [[http://golang.org/pkg/builtin/#append][Документація]]
вбудованого пакету описує `append`.

	func append(s []T, vs ...T) []T

Перший параметр `s` в `append` — це вирізка типу `T`, а інші є
значеннями `T`, що додаються до вирізки.

Значення результату `append` — це вирізка, що містить всі елементи
початкової вирізки плюс надані значення.

Якщо прихований за `s` масив є занадто малим, аби вмістити всі надані значення,
то буде виділений більший масив. Повернена вирізка вказуватиме на новий масив.

(Щоб дізнатися більше про вирізки, прочитайте статтю [[http://blog.golang.org/go-slices-usage-and-internals][Вирізки: вживання та внутрішня побудова]].)

.play moretypes/append.go

* Range

Різновид `range` циклу `for` використовується для вирізки або словника.

.play moretypes/range.go

* Range, продовження

Ви можете пропустити позицію або значення, призначаючи `_`.

Якщо потрібна тільки позиція, то ", value" можна відкинути зовсім.

.play moretypes/range-continued.go

* Вправа: Вирізки

Реалізуйте `Pic`. Вона повинна повертати вирізку довжини `dy`, кожен елемент якої є вирізкою `dx` 8-бітних беззнакових цілих. При виконанні програми, вона виведе ваше зображення, 
інтерпретуючи цілі числа як значення на шкалі чорно-білих (гаразд, синьо-білих) кольорів.

Вибір зображення лишається за вами. Серед цікавих функцій `(x+y)/2`, `x*y` та `x^y`.

(Вам потрібно буде вжити цикл для створення кожного `[]uint8` всередині `[][]uint8`.)

(Використовуйте `uint8(intValue)` для перетворення типів.)

.play moretypes/exercise-slices.go

* Словники

Словник розмічує ключі до значень.

Перед використанням, словник повинен бути створений через `make` (не `new`); словник `nil` є порожнім і не може бути присвоєний.

.play moretypes/maps.go

* Літерали словників

Літерали словників такі самі, як літерали структур, але ключі є обов’язковими.

.play moretypes/map-literals.go

* Літерали словників, продовження

Якщо на верхньому рівні просто назва типу, то її можна пропустити у переліку елементів літерала.

.play moretypes/map-literals-continued.go

* Зміна словників

Внесення чи оновлення елемента для словника `m`:

	m[key] = elem

Витягнути елемент:

	elem = m[key]

Видалити елемент:

	delete(m, key)

Перевірити, чи ключ присутній через присвоєння двох значень:

	elem, ok = m[key]

Якщо `key` присутній в `m`, `ok` рівний `true`. Якщо ні, то `ok` рівний `false`, а `elem` рівний нульовому значенню типу елементів словника.

Так само, якщо читати зі словника неіснуючий ключ, результатом є нульове значення типу елементів словника.

*Примітка:* якщо `elem` чи `ok` досі не були оголошені, ви можете застосувати короткий запис оголошення:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Вправа: Словники

Реалізуйте `WordCount`. Вона повинна повертати словник з кількістю повторень кожного «слова» в рядку `s`. Функція `wc.Test` виконує набір перевірок для даної функції та виводить успіх чи невдача.

Вам може знадобитися [[http://golang.org/pkg/strings/#Fields][strings.Fields]].

.play moretypes/exercise-maps.go

* Функції як значення

Функції також є значеннями.

.play moretypes/function-values.go

* Замикання функцій

Функції Go можуть бути замиканнями. Замикання — це фунція як значення, що посилається на змінні, які знаходяться поза її тілом. Функція може звертатись та присвоювати до цих змінних; в даному сенсі, функція є «пов’язаною» зі змінними.

Наприклад, функція `adder` повертає замикання. Кожне замикання пов’язане зі своєю власною змінною `sum`.

.play moretypes/function-closures.go

* Вправа: Замикання Фібоначчі

Давайте пограємося з фунціями.

Реалізуйте функцію `fibonacci`, яка повертає функцію (замикання), що повертатиме послідовні числа фібоначчі.

.play moretypes/exercise-fibonacci-closure.go

* Вітаємо!

Ви завершили заняття!

Ви можете повернутися до переліку [[/list][модулів]], щоб знайти, що вивчити далі, або перейти до [[javascript:click('.next-page')][наступного заняття]].
