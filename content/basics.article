Пакети, змінні та функції.
Вивчіть базові компоненти будь-якої Go програми.

Автори Go
https://golang.org

* Пакети

Кожна програма на Go складається з пакетів.

Програми починають виконання з пакету `main`.

Дана програма використовує пакети зі шляхом імпорту `"fmt"` та `"math/rand"`.

За умовою, назва пакету збігається з останнім елементом шляху імпорту. Наприклад, пакет `"math/rand"` містить файли, що починаються з інструкції `package`rand`.

#appengine: *Примітка:* середовище в якому виконуються програми є
#appengine: визначеним, тобто при кожному запуску програми прикладу
#appengine: `rand.Intn` завжди повертатиме одне й те саме число.
#appengine:
#appengine: (Щоб отримати інший результат, задайте початкове «зерно» генератора чисел; див. [[http://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play basics/packages.go

* Імпорт

Даний код об’єднує імпорт в дужки, так звана «складена» інструкція імпорту. 

Ви також можете писати декілька інструкцій імпорту, ось так:

	import "fmt"
	import "math"

Але хорошим стилем є використання складеної інструкції імпорту.

.play basics/imports.go

* Експортовані назви

В Go ім’я експортується, якщо воно починається з великої літери.

Після імпортування пакету, ви можете звертатися до імен, які він експортує.
Всі неекспортовані імена не є доступними поза самим пакетом.

`Foo` експортується, так само як `FOO`. Ім’я `foo` не експортується.

Виконайте код. Потім переіменуйте `math.pi` на `math.Pi` та спробуйте знову.

.play basics/exported-names.go

* Функції

Функція може приймати нуль або більше аргументів.

У даному прикладі `add` приймає два параметри типу `int`.

Зверніть увагу, що тип знаходиться _після_ імені змінної.

(Більше про типи та про те, чому вони виглядають саме так, дивіться у [[https://blog.golang.org/gos-declaration-syntax][статті про синтаксис декларацій Go]].)

.play basics/functions.go

* Функції, продовження

Коли двоє чи більше послідовних параметрів функції мають однаковий тип, то цей тип може бути пропущений для всіх параметрів, крім останнього.

В даному випадку, ми скоротили

	x int, y int

до

	x, y int

.play basics/functions-continued.go

* Декілька результатів

Функція може повертати будь-яке число результатів.

Функція `swap` повертає два рядки.

.play basics/multiple-results.go

* Повернення іменованих значень

В Go значення результату можуть бути іменованими. Якщо так, то вони поводяться як змінні, визначені на початку функції.

Дані імена мають свідчити про зміст повернених значень.

Інструкція `return` без аргументів повертає поточні значення результатів. Це називається «голе» повернення.

Голі повернення повинні використовуватися тільки в коротких функціях, як у даному прикладі. У довших функціях вони можуть завадити простоті читання.

.play basics/named-results.go

* Змінні

Інструкція `var` об’являє перелік змінних; так само, як для аргументів функції — тип у кінці.

Інструкція `var` може бути на рівні пакету чи фунції. В даному прикладі присутні обидва варіанти.

.play basics/variables.go

* Змінні з ініціалізацією

Оголошення var може включати ініціалізацію, окремо для кожної змінної.

Якщо присутня ініціалізація, то тип може бути пропущений — змінна прийме тип початкового значення.

.play basics/variables-with-initializers.go

* Коротке оголошення змінних

Всередині функції короткий запис присвоєння `:=` може бути використаний замість оголошення `var` з неявним типом.

Поза функцією кожна інструкція починається з ключового слова (`var`, `func` тощо), тож запис `:=` недоступний.

.play basics/short-variable-declarations.go

* Базові типи

Базові типи Go

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // псевдонім uint8

	rune // псевдонім int32
	     // представляє код символу в системі Unicode

	float32 float64

	complex64 complex128

Даний приклад показує змінні різних типів,
а також те, що оголошення змінних може бути «складена» в блоки,
схожі на інструкції імпорту.

Типи `int`, `uint` та `uintptr` зазвичай займають 32 біти на 32-бітній системі та 64 біти на 64-бітній.
Ви маєте використовувати `int` для цілих значень, за винятком коли є певні причини для використання розмірних або беззнакових типів.

.play basics/basic-types.go

* Нульові значення

Змінні, що оголошені без явного початкового значення, приймають свої
_нульові_значення_.

Нульове значення це:

- `0` для числових типів,
- `false` для булевого типу,
- `""` (пустий рядок) для рядків.

.play basics/zero.go

* Перетворення типів

Вираз `T(v)` переводить значення `v` до типу `T`.

Деякі числові перетворення:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Або спрощений запис:

	i := 42
	f := float64(i)
	u := uint(f)

На відміну від C, Go потребує явного перетворення для присвоювання елементів різного типу.
Подивіться, що станеться, якщо прибрати в прикладі перетворення `float64` чи `int`.

.play basics/type-conversions.go

* Визначення типів

Коли змінна оголошена без вказання її типу (використовуючи `var` без типу або `:=` синтаксис), то тип змінної _визначений_ зі значення на правому боці.

Коли правий бік оголошення має тип, то нова змінна приймає той самий тип:

	var i int
	j := i // j is an int

Але коли на правому боці знаходиться числова константа без типу, то нова змінна може бути `int`, `float64` чи `complex128`, залежно від точності константи:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Спробуйте змінити початкове значення `v` в коді прикладу, та спостерігайте, як це впливає на її тип.

.play basics/type-inference.go

* Константи

Константи оголошуються так само, як змінні, але з ключовим словом `const`.

Константа може бути символом, рядком, логічним (булевим) або числовим значенням.

Константи не можуть бути оголошені за допомогою синаксису `:=`.

.play basics/constants.go

* Числові константи

Числові константи — це _значення_ з високою точністю.

Констата без типу примає тип, якого потребує її контекст.

Спробуйте також вивести `needInt(Big)`.

(`int` може містити щонайбільше 64-бітне ціле число, а іноді менше.)

.play basics/numeric-constants.go

* Вітаємо!

Ви завершили заняття!

Ви можете повернутися до переліку [[/list][модулів]], щоб знайти, що вивчити далі, або перейти до [[javascript:click('.next-page')][наступного заняття]].
