Методи та інтерфейси
Дане заняття осягає методи та інтерфейси, записи, що визначають об’єкти та їхню поведінку.

Автори Go
https://golang.org

* Методи

В Go немає класів. Однак, ви можете визначати методи для типу структури.

_Одержувач_методу_ представлений у своєму власному переліку аргументів між ключовим словом `func` та назвою методу.

.play methods/methods.go

* Методи, продовження

Ви можете оголосити метод для _будь-якого_ типу, що оголошений в вашому пакеті, не тільки для структури.

Проте, ви не можете визначити метод для типу з іншого пакету (включно з вбудованими типами).

.play methods/methods-continued.go

* Методи з одержувачем вказівником

Методи можуть бути сполучені з іменованим типом або вказівником на іменований тип.

Ми побачили два методи `Abs`. Один для вказівника типу `*Vertex`, а інший для значення типу `MyFloat`.

Є дві причини на те, щоб використовувати одержувач вказівник. По-перше, аби запобігти копіюванню значення для кожного виклику методу (більш вигідно, якщо значення типу є великою структурою). По-друге, аби метод міг змінювати значення, на яке вказує одержувач.

Спробуйте змінити оголошення методів `Abs` та `Scale`, щоб вони використовували одержувач `Vertex` замість `*Vertex`.

Метод `Scale` не матиме впливу, якщо `v` є `Vertex`. `Scale` змінює `v`. Коли `v` є значенням (не вказівником) типу, то метод отримує копію `Vertex` і не має змоги змінити оригінальне значення.

`Abs` працює в обох випадках. Він тільки читає `v`. Неважливо, чи це оригінальне значення (через вказівник), чи це копія того значення.

.play methods/methods-with-pointer-receivers.go

* Інтерфейс

Тип інтерфейсу визначається набором методів.

Значення типу інтерфейс може містити будь-яке значення, що втілює дані методи.

*Примітка:* В коді прикладу є помилка на рядку 22.
`Vertex` (значення типу) не задовільняє `Abser`, бо	
метод `Abs` визначений для `*Vertex` (вказівник типу).

.play methods/interfaces.go

* Інтерфейси задовільняються неявно

Тип втілює інтерфейс через втілення методів.
Не існує вираженого оголошення наміру; нема ключового слова "implements". 

Неявні інтерфейси розділяють пакети реалізації від пакетів, що визначають інтерфейси — вони незалежні один від одного.

Це також сприяє визначенню точних інтерфейсів, бо ви не повинні шукати кожну реалізацію та навішувати на неї ім’я цього інтерфейсу.

[[http://golang.org/pkg/io/][Пакет io]] визначає `Reader` та `Writer`; ви не мусите цього робити.

.play methods/interfaces-are-satisfied-implicitly.go

* Stringer

Одним з найбільш повсюдних інтерфейсів є [[//golang.org/pkg/fmt/#Stringer][`Stringer`]], визначений в пакеті [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` — це тип, що може бути представлений рядком. Пакет `fmt`
(та багато інших) потребують цей інтерфейс, щоб виводити значення.

.play methods/stringer.go

* Вправа: Stringer

Примусьте `IPAddr` втілити `fmt.Stringer`, щоб виводити адресу як
четвірку чисел з крапками.

Наприклад, `IPAddr{1,`2,`3,`4}` має виводитися `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Помилки

Програми Go висловлюють стан помилки за допомогою значень `error`.

Тип `error` є вбудованим інтерфейсом схожим на `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Подібно до `fmt.Stringer`, пакет `fmt` очікує інтерфейс `error`, коли виводить значення.)

Функції часто повертають значення `error`. Код повинен обробляти помилки, перевіряючи чи помилка дорівнює `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

Nil `error` означає успіх; не nil `error` означає невдачу.

.play methods/errors.go

* Вправа: Помилки

Скопіюйте вашу функцію `Sqrt` з [[/flowcontrol/8][попередньої вправи]] та змініть її, щоб вона повертала значення `error`.

`Sqrt` повинна повертати не nil значення помилки, коли отримує негативне число, оскільки вона не підтримує комплексні числа.

Створіть новий тип

	type ErrNegativeSqrt float64

та зробіть його `error`, надавши йому

	func (e ErrNegativeSqrt) Error() string

метод, аби `ErrNegativeSqrt(-2).Error()` повертав `"cannot`Sqrt`negative`number:`-2"`.

*Примітка:* виклик `fmt.Sprint(e)` всередині методу `Error` відправить програму до нескінченного циклу. Цьому можна завадити, якщо спершу перетворити `e`: `fmt.Sprint(float64(e))`. Чому?

Змініть вашу функцію `Sqrt`, аби вона повертала значення `ErrNegativeSqrt`, коли отримує негативне число.

.play methods/exercise-errors.go

* Reader

Пакет `io` визнає інтерфейс `io.Reader`,
який представляє те, що стосується читання потоку даних.

Стандартна бібліотека Go містить [[https://golang.org/search?q=Read#Global][багато втілень]] даних інтерфейсів, включно з файлами, мережевими з’єднаннями, стисненням, шифруванням тощо.

Інтерфейс `io.Reader` має метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` наповнює даними отриману вирізку байтів і повертає число наповнених байтів
та значення помилки. Вона повертає помилку `io.EOF`, коли потік закінчується.

Код прикладу створює
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]].
та споживає свій вивід по 8 байтів за раз.

.play methods/reader.go

* Вправа: Reader

Реалізуйте тип `Reader`, що поширює нескінченний потік символу ASCII `'A'`.

.play methods/exercise-reader.go

* Вправа: rot13Reader

Поширеним зразком є [[https://golang.org/pkg/io/#Reader][io.Reader]], що огортає інший `io.Reader`, змінюючи потік якимось чином.

Наприклад, функція [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] приймає `io.Reader` (потік стиснених даних) і повертає `*gzip.Reader`, що також втілює `io.Reader` (потік відновлених даних).

Реалізуйте `rot13Reader`, що втілює `io.Reader` та зчитує з `io.Reader`, змінюючи потік за допомогою [[https://en.wikipedia.org/wiki/ROT13][rot13]], підстановочного шифру до всіх символів алфавіту.

Тип `rot13Reader` вже наданий.
Зробіть його `io.Reader`, втіливши метод `Read`.

.play methods/exercise-rot-reader.go

* Веб-сервери

[[https://golang.org/pkg/net/http/][Пакет http]] обслуговує запити HTTP за допомогою будь-якого значення, що втілює `http.Handler`:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

В даному прикладі, тип `Hello` втілює `http.Handler`.

Відкрийте [[http://localhost:4000/][http://localhost:4000/]], аби побачити привітання.

#appengine: *Примітка:* Даний приклад не буде виконуватися через інтерфейс веб-туру.
#appengine: Щоб спробувати писати власні веб-сервери ви маєте
#appengine: [[https://golang.org/doc/install/][Встановити Go]].

.play methods/web-servers.go

* Вправа: Обробка HTTP

Реалізуйте наступні типи та визначте для них методи ServeHTTP. Зареєструйте їх для певних адрес вашого веб-серверу.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Наприклад, ви маєте змогу зареєструвати оброблювачі так:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

#appengine: *Примітка:* Даний приклад не буде виконуватися через інтерфейс веб-туру.
#appengine: Щоб спробувати писати власні веб-сервери ви маєте
#appengine: [[https://golang.org/doc/install/][Встановити Go]].

.play methods/exercise-http-handlers.go

* Зображення

[[https://golang.org/pkg/image/#Image][Пакет image]] визначає інтерфейс `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Примітка*: значення `Rectangle` результату метода `Bounds` насправді є
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], оскільки оголошення знаходиться всередині пакету `image`.

(Дивіться [[https://golang.org/pkg/image/#Image][документацію]] заради усіх деталей.)

Типи `color.Color` та `color.Model` також є інтерфейсами, але ми не звертатимемо на це уваги, бо будемо використовувати вже визначені реалізації `color.RGBA` та `color.RGBAModel`. Дані інтерфейси і типи визначені в [[https://golang.org/pkg/image/color/][пакеті image/color]].

.play methods/images.go

* Вправа: Зображення

Пам’ятаєте генератор зображень, що ви написали раніше. Давайте напишемо ще один, але цього разу він повертатиме втілення `image.Image` замість вирізки даних.

Визначте ваш власний тип `Image`, що втілює [[https://golang.org/pkg/image/#Image][необхідні методи]], та викличте `pic.ShowImage`.

`Bounds` мусить повернути `image.Rectangle`, схоже на `image.Rect(0,`0,`w,`h)`.

`ColorModel` мусить повернути `color.RGBAModel`.

`At` має повернути колір; значення `v` в старому генераторі зображень відповідає до `color.RGBA{v,`v,`255,`255}` у цьому.

.play methods/exercise-images.go

* Вітаємо!

Ви завершили заняття!

Ви можете повернутися до переліку [[/list][модулів]], щоб знайти, що вивчити далі, або перейти до [[javascript:click('.next-page')][наступного заняття]].
