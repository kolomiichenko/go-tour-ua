Конкуренція
Go забезпечує побудови конкуренції, як частину ядра самої мови. Ці заняття розповідають про них та подають приклади, як ними користуватися.

Автори Go
https://golang.org

* Go-підпрограми

_Go-підпрограма_(goroutine)_ — це легкий потік виконання, керований середовищем Go.

	go f(x, y, z)

запускає нову go-підпрограму, що виконує

	f(x, y, z)

Визначення `f`, `x`, `y` та `z` відбувається в поточній go-підрограмі, а виконання `f` відбувається в новій go-підпрограмі.

Go-підпрограми виконуються в тому самому просторі адрес, тож доступ до спільної пам’яті має бути синхронізований. Пакет [[https://golang.org/pkg/sync/][`sync`]] надає корисні примітиви, проте вам вам вони не знадобляться так часто, як інші примітиви Go. (Дивіться наступний слайд.)

.play concurrency/goroutines.go

* Канали

Канали — це типізований пристрій, через який можна посилати та отримувати значення за допомогою оператора каналу, `<-`.

	ch <- v    // Послати v до каналу ch.
	v := <-ch  // Отримати з ch та
	           // присвоїти значення v.

(Дані йдуть в напрямку стрілочки.)

Подібно до словників і вирізок, канали мають бути створені перед використанням:

	ch := make(chan int)

За замовчуванням, відправлення та отримання блокують виконання, поки інша сторона не готова. Це дозволяє go-підпрограмам синхронізуватися без явних блокувань чи змінних стану.

.play concurrency/channels.go

* Буферизовані канали

Канали можуть бути _буферизованими_. Щоб ініціалізувати буферизований канал, надайте довжину буфера, як другий аргумент для `make`:

	ch := make(chan int, 100)

Посилання до буферизованого каналу блокує тільки тоді, коли буфер є заповненим. Отримання блокує тоді, коли буфер є порожнім.

Змініть приклад, щоб переповнити буфер, та подивіться, що станеться.

.play concurrency/buffered-channels.go

* Range та close

Відправник може закрити канал з `close`, щоб показати, що відправлень більше не буде. Отримувачі можуть перевірити, чи був канал закритий, присвоївши другий параметр у виразі отримання:

	v, ok := <-ch

`ok` є `false`, коли більше нема значень для отримання, а канал закритий.

Цикл `for`i`:=`range`c` отримує значення з каналу, повторюючись, поки він не буде закритий.

*Примітка:* Тільки відправник може закрити канал, в жодному разі отримувач. Відправлення в закритий канал викличе паніку.

*Ще*примітка*: Канали відрізняються від файлів; зазвичай у вас нема потреби їх закривати. Закриття необхідне тільки тоді, коли отримувач має бути оповіщений, що більше значень не буде, наприклад, для переривання циклу `range`.

.play concurrency/range-and-close.go

* Select

Інструкція `select` дозволяє go-підпрограмі чекати одразу на декілька операцій спілкування.

Інструкція `select` блокує, поки один з випадків не може бути запущений, тоді вона виконує цей випадок. Якщо декілька є готовими, то вона випадковим чином обирає один.

.play concurrency/select.go

* Select за замовчуванням

Випадок `default` в `select` виконується, якщо жоден інший випадок не є готовим.

Користуйтеся випадком `default`, щоб намагатися відправляти та отримувати без блокування:

	select {
	case i := <-c:
		// використовуємо i
	default:
		// отримання з c викликало б блокування
	}

.play concurrency/default-selection.go

* Вправа: Рівність двійкових дерев

З одного ряду значень, що зберігаються як вершини, може існувати багато різних двійкових дерев. Наприклад, ось двоє двійкових дерев, що містять ряд 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

Функція для перевірки, чи містять двійкові дерева однаковий ряд, є доволі складною у більшості мов. Ми використаємо конкурентність Go та канали, щоб написати просте розв’язання.

Даний приклад використовує пакет `tree`, що визначає тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

Продовження опису на [[javascript:click('.next-page')][наступній сторінці]].

* Вправа: Рівність двійкових дерев

*1.* Реалізуйте функцію `Walk`.

*2.* Перевірте функцію `Walk`.

Функція `tree.New(k)` будує двійкове дерево з випадковою структурою, що містить значення `k`, `2k`, `3k`, ..., `10k`.

Створіть новий канал `ch` та запустіть обхід:

	go Walk(tree.New(1), ch)

Потім прочитайте та виведіть 10 значень з каналу. Це мають бути числа 1, 2, 3, ..., 10.

*3.* Реалізуйте функцію `Same`, використовуючи `Walk`, щоб визначити, чи `t1` і `t2` містять однакові значення.

*4.* Перевірте функцію `Same`.

`Same(tree.New(1),`tree.New(1))` повинна повертати true, а `Same(tree.New(1),`tree.New(2))` повинна повертати false.

.play concurrency/exercise-equivalent-binary-trees.go

* Вправа: Пошуковий робот

У даній вправі ви будете використовувати можливості конкуренції Go для паралелізації пошукового бота.

Змініть функцію `Crawl`, аби витягувати URL паралельно, уникаючи витягнення одного URL двічі.

.play concurrency/exercise-web-crawler.go

* Куди Go далі...

#appengine: Ви можете почати з
#appengine: [[https://golang.org/doc/install/][встановлення Go]].

#appengine: Коли ви встановили Go,
 
[[https://golang.org/doc/][Документація Go]] є чудовим вибором для
#appengine: продовження.
початку.
Вона містить посилання, посібники, відео тощо.

Аби вивчити організацію і роботу з кодом Go, подивіться [[https://www.youtube.com/watch?v=XCsL89YtqCs][цей відеозапис]] або прочитайте [[https://golang.org/doc/code.html][Як писати код Go]].

Якщо вам потрібна допомога зі стандартною бібліотекою, дивіться [[https://golang.org/pkg/][довідник пакетів]]. Що стосується самої мови, вас може здивувати читабельність [[https://golang.org/ref/spec][Специфікації мови]].

Аби продовжити дослідження моделі конкуренції Go, подивіться
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Зразки конкуренції Go]]
([[https://talks.golang.org/2012/concurrency.slide][слайди]])
та
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Розвинені зразки конкуренції Go]]
([[https://talks.golang.org/2013/advconc.slide][слайди]])
та прочитайте
[[https://golang.org/doc/codewalk/sharemem/][Спільна пам’ять через спілкування]].

Аби почати писати веб-додатки, подивіться
[[https://vimeo.com/53221558][Просте середовище програмування]]
([[https://talks.golang.org/2012/simple.slide][слайди]])
та прочитайте посібник
[[https://golang.org/doc/articles/wiki/][Написання веб-додатків]].

[[https://golang.org/doc/codewalk/functions/][Функції першого класу в Go]] подає цікаву перспективу на функціональні типи в Go.

[[https://blog.golang.org/][Go Блог]] містить великий архів інформативних статей про Go.

Відвідайте [[https://golang.org][golang.org]] для подальшої інформації.
